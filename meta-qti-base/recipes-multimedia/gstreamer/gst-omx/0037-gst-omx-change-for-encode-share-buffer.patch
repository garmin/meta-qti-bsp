From fb55a132a8d1c57ef90b54c7d11c414fffca7076 Mon Sep 17 00:00:00 2001
From: Lily Li <lali@codeaurora.org>
Date: Thu, 8 Aug 2019 15:17:59 +0800
Subject: [PATCH 37/42] gst-omx: change for encode share buffer

Support zero copy. Encoder directly reuse frame buffer from upstream
plugin like qcarcamsrc, qvconv and hw decoder. Only support hw vpu's
nv12 and nv12_ubwc format currently. Enable this feature by setting
property share-buffer as true.

Change-Id: I1f698758bed3bd8ee77e2ddea4159d0cf81863a8
Signed-off-by: Lily Li <lali@codeaurora.org>
---
 omx/gstomx.c         | 40 ++++++++++++++++++++----
 omx/gstomx.h         | 26 +++++++++++++++-
 omx/gstomxvideoenc.c | 86 ++++++++++++++++++++++++++++++++++++++++++++++++++--
 omx/gstomxvideoenc.h |  2 +-
 4 files changed, 144 insertions(+), 10 deletions(-)

diff --git a/omx/gstomx.c b/omx/gstomx.c
index 6e0b8d4..e5298a8 100755
--- a/omx/gstomx.c
+++ b/omx/gstomx.c
@@ -23,7 +23,6 @@
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
-
 #include <gst/gst.h>
 #include <gst/allocators/gstdmabuf.h>
 #include <string.h>
@@ -2614,9 +2613,26 @@ gst_omx_port_allocate_buffers_unlocked (GstOMXPort * port,
           l->data);
       buf->eglimage = TRUE;
     } else {
-      err =
-          OMX_AllocateBuffer (comp->handle, &buf->omx_buf, port->index, buf,
-          port->port_def.nBufferSize);
+      if(port->enc_share_frame_buffer){
+        err = OMX_AllocateBuffer (comp->handle, &buf->omx_buf, port->index, buf,
+            sizeof(MetaBuffer));
+        if (err == OMX_ErrorNone && buf->omx_buf) {
+          OMX_S32 nFds = 1;
+          OMX_S32 nInts = 3;
+          MetaBuffer *pMetaBuffer = (MetaBuffer *)(buf->omx_buf->pBuffer);
+          if (pMetaBuffer) {
+            NativeHandle* pMetaHandle = (NativeHandle*)calloc((
+            sizeof(NativeHandle)+ sizeof(OMX_S32)*(nFds + nInts)), 1);
+            pMetaBuffer->meta_handle = pMetaHandle;
+            pMetaBuffer->buffer_type = CameraSource;
+          }
+        }
+        GST_DEBUG_OBJECT (comp->parent, "alloc metabuffer");
+      } else {
+        err =
+            OMX_AllocateBuffer (comp->handle, &buf->omx_buf, port->index, buf,
+            port->port_def.nBufferSize);
+      }
       buf->eglimage = FALSE;
     }
 
@@ -2681,8 +2697,15 @@ gst_omx_port_use_buffers (GstOMXPort * port, const GList * buffers)
   g_return_val_if_fail (port != NULL, OMX_ErrorUndefined);
 
   g_mutex_lock (&port->comp->lock);
-  n = g_list_length ((GList *) buffers);
-  err = gst_omx_port_allocate_buffers_unlocked (port, buffers, NULL, n);
+  if(NULL == buffers)
+  {
+    err = gst_omx_port_allocate_buffers_unlocked (port, NULL, NULL, -1);
+  }
+  else
+  {
+    n = g_list_length ((GList *) buffers);
+    err = gst_omx_port_allocate_buffers_unlocked (port, buffers, NULL, n);
+  }
   port->allocation = GST_OMX_BUFFER_ALLOCATION_USE_BUFFER;
   g_mutex_unlock (&port->comp->lock);
 
@@ -2911,6 +2934,11 @@ gst_omx_port_deallocate_buffers_unlocked (GstOMXPort * port)
       GST_DEBUG_OBJECT (comp->parent, "%s: deallocating buffer %p (%p)",
           comp->name, buf, buf->omx_buf->pBuffer);
 
+      if(port->enc_share_frame_buffer && buf->omx_buf->pBuffer && ((MetaBuffer *)(buf->omx_buf->pBuffer))->meta_handle){
+        free(((MetaBuffer *)(buf->omx_buf->pBuffer))->meta_handle);
+        ((MetaBuffer *)(buf->omx_buf->pBuffer))->meta_handle = NULL;
+      }
+
       tmp = OMX_FreeBuffer (comp->handle, port->index, buf->omx_buf);
 
       if (tmp != OMX_ErrorNone) {
diff --git a/omx/gstomx.h b/omx/gstomx.h
index 1bbced4..f0bb88f 100644
--- a/omx/gstomx.h
+++ b/omx/gstomx.h
@@ -27,6 +27,7 @@
 #include <gst/gst.h>
 #include <gst/video/video.h>
 #include <string.h>
+#include "media/hardware/MetadataBufferType.h"
 
 #ifdef HAVE_CONFIG_H
 #include "config.h"
@@ -228,6 +229,29 @@ typedef struct _GstOMXBuffer GstOMXBuffer;
 typedef struct _GstOMXClassData GstOMXClassData;
 typedef struct _GstOMXMessage GstOMXMessage;
 
+/* copy the defines of _MetaBufferType, ITUR601, _NativeHandle and _MetaBuffer
+ * from mm-video-utils
+ */
+typedef enum _MetaBufferType {
+#ifdef USE_NATIVE_HANDLE_SOURCE
+    CameraSource = 3,
+#else
+    CameraSource = 0,
+#endif
+    GrallocSource = 1,
+}MetaBufferType;
+
+#define ITUR601 0x200000
+typedef struct _NativeHandle {
+    OMX_S32 version;        /* sizeof(native_handle_t) */
+    OMX_S32 numFds;         /* number of file-descriptors at &data[0] */
+    OMX_S32 numInts;        /* number of ints at &data[numFds] */
+    OMX_S32 data[0];        /* numFds + numInts ints */
+}NativeHandle;
+typedef struct _MetaBuffer {
+    MetaBufferType buffer_type;
+    NativeHandle* meta_handle;
+}MetaBuffer;
 typedef enum {
   /* Everything good and the buffer is valid */
   GST_OMX_ACQUIRE_BUFFER_OK = 0,
@@ -347,9 +371,9 @@ struct _GstOMXPort {
    */
   gint settings_cookie;
   gint configured_settings_cookie;
-
   guint pending_bufs_before_rect_change;
   gboolean rect_changed;
+  gboolean enc_share_frame_buffer;
 };
 
 struct _GstOMXComponent {
diff --git a/omx/gstomxvideoenc.c b/omx/gstomxvideoenc.c
index 671c981..7479481 100755
--- a/omx/gstomxvideoenc.c
+++ b/omx/gstomxvideoenc.c
@@ -32,6 +32,8 @@
 #include "gstomxvideo.h"
 #include "gstomxvideoenc.h"
 #include "OMX_QCOMExtns.h"
+#include <gst/ionbuf/gstionbuf_meta.h>
+#include <gbm_priv.h>
 
 #define Log2(number, power)  { OMX_U32 temp = number; power = 0; while( (0 == (temp & 0x1)) &&  power < 16) { temp >>=0x1; power++; } }
 #define FractionToQ16(q,num,den) { OMX_U32 power; Log2(den,power); q = num << (16 - power); }
@@ -47,7 +49,12 @@
 #include <OMX_Broadcom.h>
 #include <OMX_Index.h>
 #endif
-
+struct StoreMetaDataInBuffersParams {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nPortIndex;
+    OMX_BOOL bStoreMetaData;
+};
 GST_DEBUG_CATEGORY_STATIC (gst_omx_video_enc_debug_category);
 #define GST_CAT_DEFAULT gst_omx_video_enc_debug_category
 
@@ -306,6 +313,7 @@ enum
   PROP_MAX_QUANT_P_FRAMES,
   PROP_MIN_QUANT_B_FRAMES,
   PROP_MAX_QUANT_B_FRAMES,
+  PROP_SHARE_BUFFER,
   PROP_QP_MODE,
   PROP_MIN_QP,
   PROP_MAX_QP,
@@ -352,6 +360,7 @@ enum
 #define GST_OMX_VIDEO_ENC_MIN_QUANT_B_FRAMES_DEFAULT (0xffffffff)
 #define GST_OMX_VIDEO_ENC_MAX_QUANT_B_FRAMES_DEFAULT (0xffffffff)
 
+#define GST_OMX_VIDEO_ENC_SHARE_BUFFER_DEFAULT FALSE
 #define GST_OMX_VIDEO_ENC_QP_MODE_DEFAULT (0xffffffff)
 #define GST_OMX_VIDEO_ENC_MIN_QP_DEFAULT (10)
 #define GST_OMX_VIDEO_ENC_MAX_QP_DEFAULT (51)
@@ -502,6 +511,14 @@ gst_omx_video_enc_class_init (GstOMXVideoEncClass * klass)
           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS |
           GST_PARAM_MUTABLE_READY));
 
+  g_object_class_install_property (gobject_class, PROP_SHARE_BUFFER,
+      g_param_spec_boolean ("share-buffer",
+          "share buffer with source",
+          "share buffer with source",
+          GST_OMX_VIDEO_ENC_SHARE_BUFFER_DEFAULT,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS |
+          GST_PARAM_MUTABLE_READY));
+
 #ifdef USE_OMX_TARGET_ZYNQ_USCALE_PLUS
   g_object_class_install_property (gobject_class, PROP_QP_MODE,
       g_param_spec_enum ("qp-mode", "QP mode",
@@ -740,6 +757,8 @@ gst_omx_video_enc_init (GstOMXVideoEnc * self)
   self->max_quant_p_frames = GST_OMX_VIDEO_ENC_MAX_QUANT_P_FRAMES_DEFAULT;
   self->max_quant_b_frames = GST_OMX_VIDEO_ENC_MAX_QUANT_B_FRAMES_DEFAULT;
 
+  self->enc_share_frame_buffer = GST_OMX_VIDEO_ENC_SHARE_BUFFER_DEFAULT;
+
 #ifdef USE_OMX_TARGET_ZYNQ_USCALE_PLUS
   self->qp_mode = GST_OMX_VIDEO_ENC_QP_MODE_DEFAULT;
   self->min_qp = GST_OMX_VIDEO_ENC_MIN_QP_DEFAULT;
@@ -1518,6 +1537,9 @@ gst_omx_video_enc_set_property (GObject * object, guint prop_id,
     case PROP_MAX_QUANT_B_FRAMES:
       self->max_quant_b_frames = g_value_get_uint (value);
       break;
+    case PROP_SHARE_BUFFER:
+      self->enc_share_frame_buffer = g_value_get_boolean (value);
+      break;
 
 #ifdef USE_OMX_TARGET_ZYNQ_USCALE_PLUS
     case PROP_QP_MODE:
@@ -1677,6 +1699,9 @@ gst_omx_video_enc_get_property (GObject * object, guint prop_id, GValue * value,
     case PROP_MAX_QUANT_B_FRAMES:
       g_value_set_uint (value, self->max_quant_b_frames);
       break;
+    case PROP_SHARE_BUFFER:
+      g_value_set_boolean(value, self->enc_share_frame_buffer);
+      break;
 
 #ifdef USE_OMX_TARGET_ZYNQ_USCALE_PLUS
     case PROP_QP_MODE:
@@ -2530,6 +2555,7 @@ gst_omx_video_enc_ensure_nb_in_buffers (GstOMXVideoEnc * self)
 static gboolean
 gst_omx_video_enc_allocate_in_buffers (GstOMXVideoEnc * self)
 {
+  self->enc_in_port->enc_share_frame_buffer = self->enc_share_frame_buffer;
   switch (self->input_allocation) {
     case GST_OMX_BUFFER_ALLOCATION_ALLOCATE_BUFFER:
       if (gst_omx_port_allocate_buffers (self->enc_in_port) != OMX_ErrorNone)
@@ -2540,6 +2566,9 @@ gst_omx_video_enc_allocate_in_buffers (GstOMXVideoEnc * self)
         return FALSE;
       break;
     case GST_OMX_BUFFER_ALLOCATION_USE_BUFFER:
+      if(gst_omx_port_use_buffers(self->enc_in_port, NULL) != OMX_ErrorNone)
+        return FALSE;
+      break;
     default:
       /* Not supported */
       g_return_val_if_reached (FALSE);
@@ -2604,6 +2633,9 @@ static GstOMXBufferAllocation
 gst_omx_video_enc_pick_input_allocation_mode (GstOMXVideoEnc * self,
     GstBuffer * inbuf)
 {
+  if(self->enc_share_frame_buffer)
+    return GST_OMX_BUFFER_ALLOCATION_USE_BUFFER;
+
   if (!gst_omx_is_dynamic_allocation_supported ())
     return GST_OMX_BUFFER_ALLOCATION_ALLOCATE_BUFFER;
 
@@ -2894,6 +2926,20 @@ gst_omx_video_enc_set_format (GstVideoEncoder * encoder,
       gst_omx_port_get_port_definition (self->enc_in_port, &port_def);
     }
   }
+  if(self->enc_share_frame_buffer){
+    struct StoreMetaDataInBuffersParams sMetadataMode;
+    GST_OMX_INIT_STRUCT(&sMetadataMode);
+    sMetadataMode.nPortIndex = self->enc_in_port->index;
+    sMetadataMode.bStoreMetaData = OMX_TRUE;
+    GST_DEBUG_OBJECT (self, "set meta mode");
+    if (gst_omx_component_set_parameter(self->enc_in_port->comp,
+      (OMX_INDEXTYPE)OMX_QcomIndexParamVideoMetaBufferMode,
+      (OMX_PTR)&sMetadataMode) != OMX_ErrorNone){
+        GST_ERROR_OBJECT (self, "set meta mode fail");
+        return FALSE;
+    }
+    GST_DEBUG_OBJECT (self, "set meta mode succ");
+  }
 
   negotiation_map =
       gst_omx_video_get_supported_colorformats (self->enc_in_port,
@@ -3211,7 +3257,43 @@ gst_omx_video_enc_fill_buffer (GstOMXVideoEnc * self, GstBuffer * inbuf,
   OMX_PARAM_PORTDEFINITIONTYPE *port_def = &self->enc_in_port->port_def;
   gboolean ret = FALSE;
   GstVideoFrame frame;
-
+  GST_DEBUG_OBJECT (self, "self->enc_share_frame_buffer %d", self->enc_share_frame_buffer);
+  if(self->enc_share_frame_buffer) {
+    OMX_S32 nFds = 1;
+    OMX_S32 nInts = 3;
+    GstIonBufFdMeta *meta = gst_buffer_get_ionfd_meta(inbuf);
+    gsize offset = 0;
+    gsize maxsize = 0;
+    gsize size = 0;
+    GST_DEBUG_OBJECT (self, "meta %p", meta);
+    MetaBuffer *pMetaBuffer = (MetaBuffer *)(outbuf->omx_buf->pBuffer);
+    NativeHandle* pMetaHandle = NULL;
+    if (!meta || !pMetaBuffer) {
+      GST_ERROR_OBJECT (self, "meta %p pMetaBuffer %p", meta, pMetaBuffer);
+      return FALSE;
+    }
+    pMetaHandle = pMetaBuffer->meta_handle;
+    if (!pMetaHandle) {
+      GST_ERROR_OBJECT (self, "pMetaHandle is NULL");
+      return FALSE;
+    }
+    g_warn_if_fail((outbuf->port->port_def.format.video.eColorFormat == QOMX_COLOR_FORMATYUV420PackedSemiPlanar32mCompressed || outbuf->port->port_def.format.video.eColorFormat == OMX_QCOM_COLOR_FormatYUV420PackedSemiPlanar32m/*same as QOMX_COLOR_FORMATYUV420PackedSemiPlanar32m*/) && "Enc share-buffer only support VPU nv12 and nv12_ubwc fmt!");
+    size = gst_buffer_get_sizes(inbuf, &offset, &maxsize);
+    pMetaHandle->version = sizeof(NativeHandle);
+    pMetaHandle->numFds = nFds;
+    pMetaHandle->numInts = nInts;
+    pMetaHandle->data[0] = meta->fd;
+    pMetaHandle->data[1] = 0; //offset
+    pMetaHandle->data[2] = maxsize > size ? maxsize: size;
+    pMetaHandle->data[3] = ITUR601; //TODO: will investigate this parameter's impact later
+    if (outbuf->port->port_def.format.video.eColorFormat == QOMX_COLOR_FORMATYUV420PackedSemiPlanar32mCompressed){
+      pMetaHandle->data[3] |= GBM_BO_USAGE_UBWC_ALIGNED_QTI;
+    }
+    pMetaBuffer->buffer_type = CameraSource;
+    GST_DEBUG_OBJECT (self, "fill meta buffer, buffer data size %d, max size %d, data[2] %d\n", size, maxsize, pMetaHandle->data[2]);
+    ret = TRUE;
+    goto done;
+  }
   if (info->width != port_def->format.video.nFrameWidth ||
       info->height != port_def->format.video.nFrameHeight) {
     GST_ERROR_OBJECT (self, "Width or height do not match");
diff --git a/omx/gstomxvideoenc.h b/omx/gstomxvideoenc.h
index 62ea7b9..fba2714 100644
--- a/omx/gstomxvideoenc.h
+++ b/omx/gstomxvideoenc.h
@@ -92,7 +92,7 @@ struct _GstOMXVideoEnc
   guint32 max_quant_i_frames;
   guint32 max_quant_p_frames;
   guint32 max_quant_b_frames;
-
+  gboolean enc_share_frame_buffer;
 #ifdef USE_OMX_TARGET_ZYNQ_USCALE_PLUS
   guint32 qp_mode;
   guint32 min_qp;
-- 
2.7.4

