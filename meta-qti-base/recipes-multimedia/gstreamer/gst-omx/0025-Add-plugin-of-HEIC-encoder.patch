From 328032d1dc0a6dd00bab79d8677c0b715910edb7 Mon Sep 17 00:00:00 2001
From: Lily Li <lali@codeaurora.org>
Date: Tue, 22 Oct 2019 14:48:37 +0800
Subject: [PATCH 25/42] Add plugin of HEIC encoder

1. support the NV_512 color format in gstomxvideoenc
2. add plugin of HEIC encoder

cherry-pick from 2629573

Change-Id: I22cb214b66cea50c4aa370487da3290e812da2bd
Signed-off-by: Lily Li <lali@codeaurora.org>
---
 configure.ac         |  11 ++
 omx/Makefile.am      |   7 +
 omx/gstomx.c         |   7 +
 omx/gstomxheicenc.c  | 372 +++++++++++++++++++++++++++++++++++++++++++++++++++
 omx/gstomxheicenc.h  |  67 ++++++++++
 omx/gstomxvideo.c    |   6 +
 omx/gstomxvideoenc.c |  15 +++
 7 files changed, 485 insertions(+)
 create mode 100644 omx/gstomxheicenc.c
 create mode 100644 omx/gstomxheicenc.h

diff --git a/configure.ac b/configure.ac
index 9bf9a72..238776e 100644
--- a/configure.ac
+++ b/configure.ac
@@ -410,6 +410,17 @@ if test "x$ac_cv_omx_target" = "xzynqultrascaleplus"; then
     AC_CHECK_HEADER([OMX_Allegro.h], [], [AC_ERROR([Need Allegro OMX headers to build for Zynq UltraScale+. Use --with-omx-header-path= argument to specify the path of those headers.])], [AC_INCLUDES_DEFAULT])
 fi
 
+AC_ARG_ENABLE([enable_encoder_heic],
+        AC_HELP_STRING([--enable-encoder-heic],
+                [Enable conditional compile [default=no]]),
+        [enable_encoder_heic="${enableval}"])
+
+
+AM_CONDITIONAL(ENABLE_ENCODER_HEIC, [test "x$enable_encoder_heic" = "xyes"])
+if test "x$enable_encoder_heic" = "xyes"; then
+AC_DEFINE(_ENABLE_ENCODER_HEIC_, 1, [support encoder heic])
+fi
+
 dnl *** set variables based on configure arguments ***
 
 dnl set license and copyright notice
diff --git a/omx/Makefile.am b/omx/Makefile.am
index f5fcb4d..9c175ee 100644
--- a/omx/Makefile.am
+++ b/omx/Makefile.am
@@ -35,6 +35,11 @@ DIVX_H_FILES=gstomxdivxvideodec.h \
              gstomxdivx311videodec.h
 endif
 
+if ENABLE_ENCODER_HEIC
+HEIC_C_FILES=gstomxheicenc.c
+HEIC_H_FILES=gstomxheicenc.h
+endif
+
 libgstomx_la_SOURCES = \
 	gstomx.c \
 	gstomxbufferpool.c \
@@ -56,6 +61,7 @@ libgstomx_la_SOURCES = \
 	$(H265_C_FILES) \
 	$(VP9_C_FILES) \
 	$(DIVX_C_FILES) \
+	$(HEIC_C_FILES) \
 	gstomxmpeg4videoenc.c \
 	gstomxh264enc.c \
 	gstomxh263enc.c \
@@ -89,6 +95,7 @@ noinst_HEADERS = \
 	$(H265_H_FILES) \
 	$(VP9_H_FILES) \
 	$(DIVX_H_FILES) \
+	$(HEIC_H_FILES) \
 	gstomxmpeg4videoenc.h \
 	gstomxh264enc.h \
 	gstomxh263enc.h \
diff --git a/omx/gstomx.c b/omx/gstomx.c
index 1fbc64b..6e0b8d4 100755
--- a/omx/gstomx.c
+++ b/omx/gstomx.c
@@ -53,6 +53,9 @@
 #include "gstomxvp9dec.h"
 #include "gstomxdivx311videodec.h"
 #include "gstomxdivxvideodec.h"
+#if _ENABLE_ENCODER_HEIC_
+#include "gstomxheicenc.h"
+#endif
 
 GST_DEBUG_CATEGORY (gstomx_debug);
 #define GST_CAT_DEFAULT gstomx_debug
@@ -3500,6 +3503,10 @@ static const GGetTypeFunction types[] = {
       , gst_omx_divx_video_dec_get_type
       , gst_omx_divx311_video_dec_get_type
 #endif
+#if _ENABLE_ENCODER_HEIC_
+      , gst_omx_heic_enc_get_type
+#endif
+
 
 };
 
diff --git a/omx/gstomxheicenc.c b/omx/gstomxheicenc.c
new file mode 100644
index 0000000..1944acc
--- /dev/null
+++ b/omx/gstomxheicenc.c
@@ -0,0 +1,372 @@
+/* Copyright (c) 2016-2017, 2019 The Linux Foundation. All rights reserved.
+ *
+ * Copyright (C) 2011, Hewlett-Packard Development Company, L.P.
+ * Author: Sebastian Dr√∂ge <sebastian.droege@collabora.co.uk>, Collabora Ltd.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation
+ * version 2.1 of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <gst/gst.h>
+#include "gstomxheicenc.h"
+
+#include <OMX_QCOMExtns.h>
+
+GST_DEBUG_CATEGORY_STATIC (gst_omx_heic_enc_debug_category);
+#define GST_CAT_DEFAULT gst_omx_heic_enc_debug_category
+
+/* prototypes */
+
+static gboolean gst_omx_heic_enc_set_format (GstOMXVideoEnc * enc,
+    GstOMXPort * port, GstVideoCodecState * state);
+static GstCaps *gst_omx_heic_enc_get_caps (GstOMXVideoEnc * enc,
+    GstOMXPort * port, GstVideoCodecState * state);
+static GstFlowReturn gst_omx_heic_enc_handle_output_frame (GstOMXVideoEnc *
+    self, GstOMXPort * port, GstOMXBuffer * buf, GstVideoCodecFrame * frame);
+static gboolean gst_omx_heic_enc_flush (GstVideoEncoder * enc);
+static gboolean gst_omx_heic_enc_stop (GstVideoEncoder * enc);
+static void gst_omx_heic_enc_set_property (GObject * object, guint prop_id,
+    const GValue * value, GParamSpec * pspec);
+static void gst_omx_heic_enc_get_property (GObject * object, guint prop_id,
+    GValue * value, GParamSpec * pspec);
+
+/* class initialization */
+
+#define DEBUG_INIT \
+  GST_DEBUG_CATEGORY_INIT (gst_omx_heic_enc_debug_category, "omxheicenc", 0, \
+      "debug category for gst-omx video encoder base class");
+
+#define parent_class gst_omx_heic_enc_parent_class
+G_DEFINE_TYPE_WITH_CODE (GstOMXHEICEnc, gst_omx_heic_enc,
+    GST_TYPE_OMX_VIDEO_ENC, DEBUG_INIT);
+
+static void
+gst_omx_heic_enc_class_init (GstOMXHEICEncClass * klass)
+{
+  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
+  GstElementClass *element_class = GST_ELEMENT_CLASS (klass);
+  GstOMXVideoEncClass *videoenc_class = GST_OMX_VIDEO_ENC_CLASS (klass);
+  GstVideoEncoderClass *basevideoenc_class = GST_VIDEO_ENCODER_CLASS (klass);
+  videoenc_class->set_format = GST_DEBUG_FUNCPTR (gst_omx_heic_enc_set_format);
+  videoenc_class->get_caps = GST_DEBUG_FUNCPTR (gst_omx_heic_enc_get_caps);
+
+  gobject_class->set_property = gst_omx_heic_enc_set_property;
+  gobject_class->get_property = gst_omx_heic_enc_get_property;
+
+  basevideoenc_class->flush = gst_omx_heic_enc_flush;
+  basevideoenc_class->stop = gst_omx_heic_enc_stop;
+  videoenc_class->cdata.default_src_template_caps = "video/x-heic,"
+      "width=(int) [ 16, 4096 ], " "height=(int) [ 16, 4096 ]";
+
+  videoenc_class->handle_output_frame =
+      GST_DEBUG_FUNCPTR (gst_omx_heic_enc_handle_output_frame);
+  gst_element_class_set_static_metadata (element_class,
+      "OpenMAX HEIC Video Encoder",
+      "Codec/Encoder/Video",
+      "Encode HEIC video streams",
+      "Miaomiao Chen <miaochen@codeaurora.org>");
+
+  gst_omx_set_default_role (&videoenc_class->cdata, "image_encoder.heic");
+
+}
+
+static void
+gst_omx_heic_enc_set_property (GObject * object, guint prop_id,
+    const GValue * value, GParamSpec * pspec)
+{
+  switch (prop_id) {
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+}
+static void
+gst_omx_heic_enc_get_property (GObject * object, guint prop_id, GValue * value,
+    GParamSpec * pspec)
+{
+  switch (prop_id) {
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+}
+
+static void
+gst_omx_heic_enc_init (GstOMXHEICEnc * self)
+{
+}
+
+static gboolean
+gst_omx_heic_enc_flush (GstVideoEncoder * enc)
+{
+  GstOMXHEICEnc *self = GST_OMX_HEIC_ENC (enc);
+
+  g_list_free_full (self->headers, (GDestroyNotify) gst_buffer_unref);
+  self->headers = NULL;
+
+  return GST_VIDEO_ENCODER_CLASS (parent_class)->flush (enc);
+}
+
+static gboolean
+gst_omx_heic_enc_stop (GstVideoEncoder * enc)
+{
+  GstOMXHEICEnc *self = GST_OMX_HEIC_ENC (enc);
+
+  g_list_free_full (self->headers, (GDestroyNotify) gst_buffer_unref);
+  self->headers = NULL;
+
+  return GST_VIDEO_ENCODER_CLASS (parent_class)->stop (enc);
+}
+
+static gboolean
+gst_omx_heic_enc_set_format (GstOMXVideoEnc * enc, GstOMXPort * port,
+    GstVideoCodecState * state)
+{
+  GstOMXHEICEnc *self = GST_OMX_HEIC_ENC (enc);
+  GstCaps *peercaps;
+  OMX_PARAM_PORTDEFINITIONTYPE port_def;
+  OMX_VIDEO_PARAM_PROFILELEVELTYPE param;
+  OMX_ERRORTYPE err;
+  const gchar *profile_string, *level_string;
+
+  gst_omx_port_get_port_definition (GST_OMX_VIDEO_ENC (self)->enc_out_port,
+      &port_def);
+  port_def.format.video.eCompressionFormat = OMX_VIDEO_CodingImageHEIC;
+  err =
+      gst_omx_port_update_port_definition (GST_OMX_VIDEO_ENC
+      (self)->enc_out_port, &port_def);
+  if (err != OMX_ErrorNone) {
+    GST_WARNING_OBJECT (self,
+        "Update output port definition failed");
+    return FALSE;
+  }
+
+  GST_OMX_INIT_STRUCT (&param);
+  param.nPortIndex = GST_OMX_VIDEO_ENC (self)->enc_out_port->index;
+  err =
+      gst_omx_component_get_parameter (GST_OMX_VIDEO_ENC (self)->enc,
+      OMX_IndexParamVideoProfileLevelCurrent, &param);
+  if (err != OMX_ErrorNone) {
+    GST_WARNING_OBJECT (self,
+        "Getting profile/level not supported by component");
+    return TRUE;
+  }
+
+  peercaps = gst_pad_peer_query_caps (GST_VIDEO_ENCODER_SRC_PAD (enc),
+    gst_pad_get_pad_template_caps (GST_VIDEO_ENCODER_SRC_PAD (enc)));
+  if (peercaps) {
+    GstStructure *s;
+
+    if (gst_caps_is_empty (peercaps)) {
+      gst_caps_unref (peercaps);
+      GST_ERROR_OBJECT (self, "Empty caps");
+      return FALSE;
+    }
+
+    s = gst_caps_get_structure (peercaps, 0);
+    profile_string = gst_structure_get_string (s, "profile");
+    if (profile_string) {
+      if (g_str_equal (profile_string, "main")) {
+        param.eProfile = OMX_VIDEO_HEVCProfileMain;
+      } else if (g_str_equal (profile_string, "mainstill")) {
+        param.eProfile = OMX_VIDEO_HEVCProfileMainStill;
+      } else {
+        goto unsupported_profile;
+      }
+    }
+    level_string = gst_structure_get_string (s, "level");
+    if (level_string) {
+      if (g_str_equal (level_string, "1")) {
+        param.eLevel = OMX_VIDEO_HEVCMainTierLevel1;
+      } else if (g_str_equal (level_string, "2")) {
+        param.eLevel = OMX_VIDEO_HEVCMainTierLevel2;
+      } else if (g_str_equal (level_string, "2.1")) {
+        param.eLevel = OMX_VIDEO_HEVCMainTierLevel21;
+      } else if (g_str_equal (level_string, "3")) {
+        param.eLevel = OMX_VIDEO_HEVCMainTierLevel3;
+      } else if (g_str_equal (level_string, "3.1")) {
+        param.eLevel = OMX_VIDEO_HEVCMainTierLevel31;
+      } else if (g_str_equal (level_string, "4")) {
+        param.eLevel = OMX_VIDEO_HEVCMainTierLevel4;
+      } else if (g_str_equal (level_string, "4.1")) {
+        param.eLevel = OMX_VIDEO_HEVCMainTierLevel41;
+      } else if (g_str_equal (level_string, "5")) {
+        param.eLevel = OMX_VIDEO_HEVCMainTierLevel5;
+      } else if (g_str_equal (level_string, "5.1")) {
+        param.eLevel = OMX_VIDEO_HEVCMainTierLevel51;
+      } else {
+        goto unsupported_level;
+      }
+    }
+
+    gst_caps_unref (peercaps);
+  }
+
+  err =
+      gst_omx_component_set_parameter (GST_OMX_VIDEO_ENC (self)->enc,
+      OMX_IndexParamVideoProfileLevelCurrent, &param);
+
+  if (err == OMX_ErrorUnsupportedIndex) {
+    GST_WARNING_OBJECT (self,
+        "Setting profile/level not supported by component");
+  } else if (err != OMX_ErrorNone) {
+    GST_ERROR_OBJECT (self,
+        "Error setting profile %u and level %u: %s (0x%08x)",
+        (guint) param.eProfile, (guint) param.eLevel,
+        gst_omx_error_to_string (err), err);
+    return FALSE;
+  }
+
+  return TRUE;
+
+unsupported_profile:
+  GST_ERROR_OBJECT (self, "Unsupported profile %s", profile_string);
+
+  return FALSE;
+
+unsupported_level:
+  GST_ERROR_OBJECT (self, "Unsupported level %s", level_string);
+
+  return FALSE;
+}
+
+static GstCaps *
+gst_omx_heic_enc_get_caps (GstOMXVideoEnc * enc, GstOMXPort * port,
+    GstVideoCodecState * state)
+{
+  GstOMXHEICEnc *self = GST_OMX_HEIC_ENC (enc);
+  GstCaps *caps;
+  OMX_ERRORTYPE err;
+  OMX_VIDEO_PARAM_PROFILELEVELTYPE param;
+  const gchar *profile, *level;
+
+  caps = gst_caps_new_simple ("video/x-heic",
+      "stream-format", G_TYPE_STRING, "byte-stream",
+      "alignment", G_TYPE_STRING, "au", NULL);
+
+  GST_OMX_INIT_STRUCT (&param);
+  param.nPortIndex = GST_OMX_VIDEO_ENC (self)->enc_out_port->index;
+
+  err =
+      gst_omx_component_get_parameter (GST_OMX_VIDEO_ENC (self)->enc,
+      OMX_IndexParamVideoProfileLevelCurrent, &param);
+  if (err != OMX_ErrorNone && err != OMX_ErrorUnsupportedIndex) {
+    gst_caps_unref (caps);
+    return NULL;
+  }
+
+  if (err == OMX_ErrorNone) {
+    switch (param.eProfile) {
+      case OMX_VIDEO_HEVCProfileMain:
+        profile = "main";
+      case OMX_VIDEO_HEVCProfileMainStill:
+        profile = "mainstill";
+        break;
+      default:
+        g_assert_not_reached ();
+        return NULL;
+    }
+
+    switch (param.eLevel) {
+      case OMX_VIDEO_HEVCMainTierLevel1:
+        level = "1";
+        break;
+      case OMX_VIDEO_HEVCMainTierLevel2:
+        level = "2";
+        break;
+      case OMX_VIDEO_HEVCMainTierLevel21:
+        level = "2.1";
+        break;
+      case OMX_VIDEO_HEVCMainTierLevel3:
+        level = "3";
+        break;
+      case OMX_VIDEO_HEVCMainTierLevel31:
+        level = "3.1";
+        break;
+      case OMX_VIDEO_HEVCMainTierLevel4:
+        level = "4";
+        break;
+      case OMX_VIDEO_HEVCMainTierLevel41:
+        level = "4.1";
+        break;
+      case OMX_VIDEO_HEVCMainTierLevel5:
+        level = "5";
+        break;
+      case OMX_VIDEO_HEVCMainTierLevel51:
+        level = "5.1";
+        break;
+      default:
+        g_assert_not_reached ();
+        return NULL;
+    }
+
+    gst_caps_set_simple (caps,
+        "profile", G_TYPE_UINT, profile, "level", G_TYPE_UINT, level, NULL);
+  }
+
+  return caps;
+}
+static GstFlowReturn
+gst_omx_heic_enc_handle_output_frame (GstOMXVideoEnc * enc, GstOMXPort * port,
+    GstOMXBuffer * buf, GstVideoCodecFrame * frame)
+{
+  GstOMXHEICEnc *self = GST_OMX_HEIC_ENC (enc);
+
+  if (!buf->omx_buf) {
+    GST_ERROR_OBJECT (self, "omx buf is NULL");
+    return GST_FLOW_ERROR;
+  }
+
+  GST_DEBUG_OBJECT (self, "buf->omx_buf->nFlags = 0x%x",buf->omx_buf->nFlags);
+  if (buf->omx_buf->nFlags & OMX_BUFFERFLAG_CODECCONFIG) {
+    /* The codec data is /VPS/SPS/PPS with a startcode => bytestream stream format
+     * For bytestream stream format the VPS/SPS/PPS is only in-stream and not
+     * in the caps!
+     */
+    if (buf->omx_buf->nFilledLen >= 4 &&
+        GST_READ_UINT32_BE (buf->omx_buf->pBuffer +
+            buf->omx_buf->nOffset) == 0x00000001) {
+      GstBuffer *hdrs;
+      GstMapInfo map = GST_MAP_INFO_INIT;
+
+      GST_DEBUG_OBJECT (self, "got codecconfig in byte-stream format");
+
+      hdrs = gst_buffer_new_and_alloc (buf->omx_buf->nFilledLen);
+
+      gst_buffer_map (hdrs, &map, GST_MAP_WRITE);
+      memcpy (map.data,
+          buf->omx_buf->pBuffer + buf->omx_buf->nOffset,
+          buf->omx_buf->nFilledLen);
+      gst_buffer_unmap (hdrs, &map);
+      self->headers = g_list_append (self->headers, hdrs);
+
+      if (frame)
+        gst_video_codec_frame_unref (frame);
+
+      return GST_FLOW_OK;
+    }
+  } else if (self->headers) {
+    gst_video_encoder_set_headers (GST_VIDEO_ENCODER (self), self->headers);
+    self->headers = NULL;
+  }
+
+  return
+      GST_OMX_VIDEO_ENC_CLASS
+      (gst_omx_heic_enc_parent_class)->handle_output_frame (enc, port, buf,
+      frame);
+}
diff --git a/omx/gstomxheicenc.h b/omx/gstomxheicenc.h
new file mode 100644
index 0000000..1c7f455
--- /dev/null
+++ b/omx/gstomxheicenc.h
@@ -0,0 +1,67 @@
+/* Copyright (c) 2016-2017, 2019 The Linux Foundation. All rights reserved.
+ *
+ * Copyright (C) 2011, Hewlett-Packard Development Company, L.P.
+ * Author: Sebastian Dr√∂ge <sebastian.droege@collabora.co.uk>, Collabora Ltd.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation
+ * version 2.1 of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA
+ */
+
+#ifndef __GST_OMX_HEIC_ENC_H__
+#define __GST_OMX_HEIC_ENC_H__
+
+#include <gst/gst.h>
+#include "gstomxvideoenc.h"
+
+G_BEGIN_DECLS
+
+#define GST_TYPE_OMX_HEIC_ENC \
+  (gst_omx_heic_enc_get_type())
+#define GST_OMX_HEIC_ENC(obj) \
+  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_OMX_HEIC_ENC,GstOMXHEICEnc))
+#define GST_OMX_HEIC_ENC_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_OMX_HEIC_ENC,GstOMXHEICEncClass))
+#define GST_OMX_HEIC_ENC_GET_CLASS(obj) \
+  (G_TYPE_INSTANCE_GET_CLASS((obj),GST_TYPE_OMX_HEIC_ENC,GstOMXHEICEncClass))
+#define GST_IS_OMX_HEIC_ENC(obj) \
+  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_OMX_HEIC_ENC))
+#define GST_IS_OMX_HEIC_ENC_CLASS(obj) \
+  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_OMX_HEIC_ENC))
+
+typedef struct _GstOMXHEICEnc GstOMXHEICEnc;
+typedef struct _GstOMXHEICEncClass GstOMXHEICEncClass;
+
+typedef enum _GstOMXHEICEncSliceMode
+{
+  GST_OMX_HEIC_ENC_SLICE_MODE_DISABLE = 0,
+  GST_OMX_HEIC_ENC_SLICE_MODE_BITS = 3
+}GstOMXHEICEncSliceMode;
+
+struct _GstOMXHEICEnc
+{
+  GstOMXVideoEnc parent;
+  GList *headers;
+};
+
+struct _GstOMXHEICEncClass
+{
+  GstOMXVideoEncClass parent_class;
+};
+
+GType gst_omx_heic_enc_get_type (void);
+
+G_END_DECLS
+
+#endif /* __GST_OMX_HEIC_ENC_H__ */
+
diff --git a/omx/gstomxvideo.c b/omx/gstomxvideo.c
index 7106ceb..da4d9b3 100644
--- a/omx/gstomxvideo.c
+++ b/omx/gstomxvideo.c
@@ -54,6 +54,12 @@ gst_omx_video_get_format_from_omx (OMX_COLOR_FORMATTYPE omx_colorformat)
      * format support */
       format = GST_VIDEO_FORMAT_NV12;
       break;
+#if _ENABLE_ENCODER_HEIC_
+    case QOMX_COLOR_FormatYUV420PackedSemiPlanar512m:
+    /* For SA8155: add new color format NV12_512 */
+      format = GST_VIDEO_FORMAT_NV12_512;
+      break;
+#endif
     case OMX_COLOR_FormatYUV422SemiPlanar:
       format = GST_VIDEO_FORMAT_NV16;
       break;
diff --git a/omx/gstomxvideoenc.c b/omx/gstomxvideoenc.c
index ee09008..90d370d 100644
--- a/omx/gstomxvideoenc.c
+++ b/omx/gstomxvideoenc.c
@@ -1895,6 +1895,13 @@ gst_omx_video_enc_configure_input_buffer (GstOMXVideoEnc * self,
           port_def.format.video.nFrameWidth,
           port_def.format.video.nFrameHeight);
       break;
+#if _ENABLE_ENCODER_HEIC_
+    case QOMX_COLOR_FormatYUV420PackedSemiPlanar512m:
+      port_def.nBufferSize = VENUS_BUFFER_SIZE(COLOR_FMT_NV12_512,
+          port_def.format.video.nFrameWidth,
+          port_def.format.video.nFrameHeight);
+    break;
+#endif
     default:
       GST_ERROR_OBJECT (self, "Unsupported port format %x",
           port_def.format.video.eColorFormat);
@@ -2268,6 +2275,11 @@ gst_omx_video_enc_set_format (GstVideoEncoder * encoder,
       case GST_VIDEO_FORMAT_NV12:
         port_def.format.video.eColorFormat = OMX_COLOR_FormatYUV420SemiPlanar;
         break;
+#if _ENABLE_ENCODER_HEIC_
+      case GST_VIDEO_FORMAT_NV12_512:
+        port_def.format.video.eColorFormat = QOMX_COLOR_FormatYUV420PackedSemiPlanar512m;
+        break;
+#endif
       case GST_VIDEO_FORMAT_NV12_UBWC:
         port_def.format.video.eColorFormat = QOMX_COLOR_FORMATYUV420PackedSemiPlanar32mCompressed;
         break;
@@ -2699,6 +2711,9 @@ gst_omx_video_enc_fill_buffer (GstOMXVideoEnc * self, GstBuffer * inbuf,
       ret = TRUE;
       break;
     }
+#if _ENABLE_ENCODER_HEIC_
+    case GST_VIDEO_FORMAT_NV12_512:
+#endif
     case GST_VIDEO_FORMAT_RGBA_UBWC:
     case GST_VIDEO_FORMAT_NV12_UBWC:
     {
-- 
2.7.4

