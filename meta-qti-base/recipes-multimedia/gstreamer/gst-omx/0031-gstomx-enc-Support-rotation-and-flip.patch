From 5cdc8dbd6959a5de7d8471239fc9242c190f5ed3 Mon Sep 17 00:00:00 2001
From: Miaomiao Chen <miaochen@codeaurora.org>
Date: Tue, 26 Feb 2019 10:57:58 +0800
Subject: [PATCH 31/42] gstomx enc: Support rotation and flip

Change-Id: I0cbf170760df8d4b0635bbf73239b2404a54d51c
Signed-off-by: Miaomiao Chen <miaochen@codeaurora.org>
---
 omx/gstomxvideoenc.c | 93 ++++++++++++++++++++++++++++++++++++++++++++++++++++
 omx/gstomxvideoenc.h |  2 ++
 2 files changed, 95 insertions(+)

diff --git a/omx/gstomxvideoenc.c b/omx/gstomxvideoenc.c
index 4478a0f..4151f60 100644
--- a/omx/gstomxvideoenc.c
+++ b/omx/gstomxvideoenc.c
@@ -74,6 +74,26 @@ gst_omx_video_enc_control_rate_get_type (void)
   return qtype;
 }
 
+#define GST_TYPE_OMX_VIDEO_ENC_MIRROR (gst_omx_video_enc_mirror_get_type ())
+static GType
+gst_omx_video_enc_mirror_get_type (void)
+{
+  static GType qtype = 0;
+
+  if (qtype == 0) {
+    static const GEnumValue values[] = {
+      {OMX_MirrorNone, "None", "none"},
+      {OMX_MirrorVertical, "Vertical", "vertical"},
+      {OMX_MirrorHorizontal, "Horizontal", "horizontal"},
+      {OMX_MirrorBoth, "Both", "both"},
+      {0, NULL, NULL}
+    };
+
+    qtype = g_enum_register_static ("GstOMXVideoEncMirror", values);
+  }
+  return qtype;
+}
+
 #ifdef USE_OMX_TARGET_ZYNQ_USCALE_PLUS
 #define GST_TYPE_OMX_VIDEO_ENC_QP_MODE (gst_omx_video_enc_qp_mode_get_type ())
 static GType
@@ -277,6 +297,8 @@ enum
   PROP_SLICE_SIZE,
   PROP_DEPENDENT_SLICE,
   PROP_DEFAULT_ROI_QUALITY,
+  PROP_ROTATION,
+  PROP_MIRROR,
 };
 
 /* FIXME: Better defaults */
@@ -311,6 +333,9 @@ enum
 #define GST_OMX_VIDEO_ENC_SLICE_SIZE_DEFAULT (0)
 #define GST_OMX_VIDEO_ENC_DEPENDENT_SLICE_DEFAULT (FALSE)
 #define GST_OMX_VIDEO_ENC_DEFAULT_ROI_QUALITY OMX_ALG_ROI_QUALITY_HIGH
+#define GST_OMX_VIDEO_ENC_ROTATION_DEFAULT (0)
+#define GST_OMX_VIDEO_ENC_MIRROR_DEFAULT (0)
+
 
 /* class initialization */
 #define do_init \
@@ -558,6 +583,20 @@ gst_omx_video_enc_class_init (GstOMXVideoEncClass * klass)
           GST_OMX_VIDEO_ENC_DEFAULT_ROI_QUALITY,
           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 #endif
+  g_object_class_install_property (gobject_class, PROP_ROTATION,
+      g_param_spec_uint ("rotation", "Rotate the input frame",
+          "rotate (0=no rotation)",
+          0, G_MAXUINT, GST_OMX_VIDEO_ENC_ROTATION_DEFAULT,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS |
+          GST_PARAM_MUTABLE_READY));
+
+  g_object_class_install_property (gobject_class, PROP_MIRROR,
+      g_param_spec_enum ("mirror", "mirror the input frame",
+          "mirror (0=donot mirror)",
+          GST_TYPE_OMX_VIDEO_ENC_MIRROR,
+          GST_OMX_VIDEO_ENC_MIRROR_DEFAULT,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS |
+          GST_PARAM_MUTABLE_READY));
 
   element_class->change_state =
       GST_DEBUG_FUNCPTR (gst_omx_video_enc_change_state);
@@ -624,6 +663,8 @@ gst_omx_video_enc_init (GstOMXVideoEnc * self)
 #endif
 
   self->default_target_bitrate = GST_OMX_PROP_OMX_DEFAULT;
+  self->rotation = GST_OMX_VIDEO_ENC_ROTATION_DEFAULT;
+  self->mirror = GST_OMX_VIDEO_ENC_MIRROR_DEFAULT;
 
   g_mutex_init (&self->drain_lock);
   g_cond_init (&self->drain_cond);
@@ -1098,6 +1139,42 @@ gst_omx_video_enc_open (GstVideoEncoder * encoder)
       }
     }
 
+    if (self->rotation) {
+      OMX_CONFIG_ROTATIONTYPE framerotate;
+      GST_OMX_INIT_STRUCT (&framerotate);
+      if (self->enc) {
+        OMX_ERRORTYPE err;
+        framerotate.nPortIndex = self->enc_out_port->index;
+        framerotate.nRotation = (OMX_S32)self->rotation;
+        err = gst_omx_component_set_config(self->enc, OMX_IndexConfigCommonRotate, (OMX_PTR)&framerotate);
+        if (err != OMX_ErrorNone) {
+          GST_ERROR_OBJECT (self,
+              "Failed to set rotation parameter: %s (0x%08x)",
+              gst_omx_error_to_string (err), err);
+        } else {
+          GST_INFO_OBJECT(self, "set rotation:%d", self->rotation);
+        }
+      }
+    }
+
+    if (self->mirror) {
+      OMX_CONFIG_MIRRORTYPE framemirror;
+      GST_OMX_INIT_STRUCT (&framemirror);
+      if (self->enc) {
+        OMX_ERRORTYPE err;
+        framemirror.nPortIndex = self->enc_out_port->index;
+        framemirror.eMirror = (OMX_MIRRORTYPE)self->mirror;
+        err = gst_omx_component_set_config(self->enc, OMX_IndexConfigCommonMirror, (OMX_PTR)&framemirror);
+        if (err != OMX_ErrorNone) {
+          GST_ERROR_OBJECT (self,
+              "Failed to set mirror parameter: %s (0x%08x)",
+              gst_omx_error_to_string (err), err);
+        } else {
+          GST_INFO_OBJECT(self, "set mirror:%d", self->mirror);
+        }
+      }
+    }
+
   }
 #ifdef USE_OMX_TARGET_ZYNQ_USCALE_PLUS
   if (!set_zynqultrascaleplus_props (self))
@@ -1294,6 +1371,15 @@ gst_omx_video_enc_set_property (GObject * object, guint prop_id,
       self->default_roi_quality = g_value_get_enum (value);
       break;
 #endif
+
+    case PROP_ROTATION:
+      self->rotation = g_value_get_uint (value);
+      GST_INFO_OBJECT(self, "set rotation:%d", self->rotation);
+      break;
+    case PROP_MIRROR:
+      self->mirror = g_value_get_enum (value);
+      GST_INFO_OBJECT(self, "set mirror:%d", self->mirror);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -1402,6 +1488,13 @@ gst_omx_video_enc_get_property (GObject * object, guint prop_id, GValue * value,
       g_value_set_enum (value, self->default_roi_quality);
       break;
 #endif
+
+    case PROP_ROTATION:
+      g_value_set_uint (value, self->rotation);
+      break;
+    case PROP_MIRROR:
+      g_value_set_enum (value, self->mirror);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
diff --git a/omx/gstomxvideoenc.h b/omx/gstomxvideoenc.h
index ead13cc..8c31b88 100644
--- a/omx/gstomxvideoenc.h
+++ b/omx/gstomxvideoenc.h
@@ -112,6 +112,8 @@ struct _GstOMXVideoEnc
   gint default_roi_quality;
 #endif
 
+  guint32 rotation;
+  guint32 mirror;
   guint32 default_target_bitrate;
 
   GstFlowReturn downstream_flow_ret;
-- 
2.7.4

