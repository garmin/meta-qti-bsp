From 7bfe4880c8422027f855bdf89b7a4ecd6a233d2b Mon Sep 17 00:00:00 2001
From: Bo Fang <bofang1@codeaurora.org>
Date: Sun, 1 Dec 2019 00:52:23 +0800
Subject: [PATCH 13/28] waylandsink: clean code and indent

Change-Id: I60b0d98e9d89d44ee6811a42dca448c192817ebb
Signed-off-by: Bo Fang <bofang1@codeaurora.org>
---
 ext/wayland/gstwaylandsink.c | 384 ++++++++++++++++++++++---------------------
 1 file changed, 193 insertions(+), 191 deletions(-)

diff --git a/ext/wayland/gstwaylandsink.c b/ext/wayland/gstwaylandsink.c
index 8bba30f..81407cd 100644
--- a/ext/wayland/gstwaylandsink.c
+++ b/ext/wayland/gstwaylandsink.c
@@ -997,243 +997,245 @@ gst_wayland_sink_show_frame (GstVideoSink * vsink, GstBuffer * buffer)
 
   ionBufFdMeta = gst_wayland_sink_read_ionbuffd(sink, buffer);
   if (!ionBufFdMeta) {
-  /* update video info from video meta */
-  mem = gst_buffer_peek_memory (buffer, 0);
+    /* update video info from video meta */
+    mem = gst_buffer_peek_memory (buffer, 0);
 
-  old_vinfo = sink->video_info;
-  vmeta = gst_buffer_get_video_meta (buffer);
-  if (vmeta) {
-    gint i;
+    old_vinfo = sink->video_info;
+    vmeta = gst_buffer_get_video_meta (buffer);
+    if (vmeta) {
+      gint i;
 
-    for (i = 0; i < vmeta->n_planes; i++) {
-      sink->video_info.offset[i] = vmeta->offset[i];
-      sink->video_info.stride[i] = vmeta->stride[i];
+      for (i = 0; i < vmeta->n_planes; i++) {
+        sink->video_info.offset[i] = vmeta->offset[i];
+        sink->video_info.stride[i] = vmeta->stride[i];
+      }
+      sink->video_info.size = gst_buffer_get_size (buffer);
     }
-    sink->video_info.size = gst_buffer_get_size (buffer);
-  }
 
-  GST_LOG_OBJECT (sink, "buffer %p does not have a wl_buffer from our "
+    GST_LOG_OBJECT (sink, "buffer %p does not have a wl_buffer from our "
       "display, creating it", buffer);
 
-  format = GST_VIDEO_INFO_FORMAT (&sink->video_info);
-  if (gst_wl_display_check_format_for_dmabuf (sink->display, format)) {
-    guint i, nb_dmabuf = 0;
+    format = GST_VIDEO_INFO_FORMAT (&sink->video_info);
+    if (gst_wl_display_check_format_for_dmabuf (sink->display, format)) {
+      guint i, nb_dmabuf = 0;
 
-    for (i = 0; i < gst_buffer_n_memory (buffer); i++)
-      if (gst_is_dmabuf_memory (gst_buffer_peek_memory (buffer, i)))
-        nb_dmabuf++;
+      for (i = 0; i < gst_buffer_n_memory (buffer); i++)
+        if (gst_is_dmabuf_memory (gst_buffer_peek_memory (buffer, i)))
+          nb_dmabuf++;
 
-    if (nb_dmabuf && (nb_dmabuf == gst_buffer_n_memory (buffer)))
-      wbuf = gst_wl_linux_dmabuf_construct_wl_buffer (buffer, sink->display,
+      if (nb_dmabuf && (nb_dmabuf == gst_buffer_n_memory (buffer)))
+        wbuf = gst_wl_linux_dmabuf_construct_wl_buffer (buffer, sink->display,
           &sink->video_info);
-  }
+    }
 
-  if (!wbuf && gst_wl_display_check_format_for_shm (sink->display, format)) {
-    if (gst_buffer_n_memory (buffer) == 1 && gst_is_fd_memory (mem))
-      wbuf = gst_wl_shm_memory_construct_wl_buffer (mem, sink->display,
+    if (!wbuf && gst_wl_display_check_format_for_shm (sink->display, format)) {
+      if (gst_buffer_n_memory (buffer) == 1 && gst_is_fd_memory (mem))
+        wbuf = gst_wl_shm_memory_construct_wl_buffer (mem, sink->display,
           &sink->video_info);
 
-    /* If nothing worked, copy into our internal pool */
-    if (!wbuf) {
-      GstVideoFrame src, dst;
-      GstVideoInfo src_info = sink->video_info;
+      /* If nothing worked, copy into our internal pool */
+      if (!wbuf) {
+        GstVideoFrame src, dst;
+        GstVideoInfo src_info = sink->video_info;
 
-      /* rollback video info changes */
-      sink->video_info = old_vinfo;
+        /* rollback video info changes */
+        sink->video_info = old_vinfo;
 
-      /* we don't know how to create a wl_buffer directly from the provided
-       * memory, so we have to copy the data to shm memory that we know how
-       * to handle... */
+        /* we don't know how to create a wl_buffer directly from the provided
+         * memory, so we have to copy the data to shm memory that we know how
+         * to handle... */
 
-      GST_LOG_OBJECT (sink, "buffer %p cannot have a wl_buffer, "
+        GST_LOG_OBJECT (sink, "buffer %p cannot have a wl_buffer, "
           "copying to wl_shm memory", buffer);
 
-      /* sink->pool always exists (created in set_caps), but it may not
-       * be active if upstream is not using it */
-      if (!gst_buffer_pool_is_active (sink->pool)) {
-        GstStructure *config;
-        GstCaps *caps;
+        /* sink->pool always exists (created in set_caps), but it may not
+         * be active if upstream is not using it */
+        if (!gst_buffer_pool_is_active (sink->pool)) {
+          GstStructure *config;
+          GstCaps *caps;
 
-        config = gst_buffer_pool_get_config (sink->pool);
-        gst_buffer_pool_config_get_params (config, &caps, NULL, NULL, NULL);
+          config = gst_buffer_pool_get_config (sink->pool);
+          gst_buffer_pool_config_get_params (config, &caps, NULL, NULL, NULL);
 
-        /* revert back to default strides and offsets */
-        gst_video_info_from_caps (&sink->video_info, caps);
-        gst_buffer_pool_config_set_params (config, caps, sink->video_info.size,
+          /* revert back to default strides and offsets */
+          gst_video_info_from_caps (&sink->video_info, caps);
+          gst_buffer_pool_config_set_params (config, caps, sink->video_info.size,
             2, 0);
 
-        /* This is a video pool, it should not fail with basic setings */
-        if (!gst_buffer_pool_set_config (sink->pool, config) ||
+          /* This is a video pool, it should not fail with basic setings */
+          if (!gst_buffer_pool_set_config (sink->pool, config) ||
             !gst_buffer_pool_set_active (sink->pool, TRUE))
-          goto activate_failed;
-      }
+            goto activate_failed;
+        }
 
-      ret = gst_buffer_pool_acquire_buffer (sink->pool, &to_render, NULL);
-      if (ret != GST_FLOW_OK)
-        goto no_buffer;
+        ret = gst_buffer_pool_acquire_buffer (sink->pool, &to_render, NULL);
+        if (ret != GST_FLOW_OK)
+          goto no_buffer;
 
-      wlbuffer = gst_buffer_get_wl_buffer (to_render);
+        wlbuffer = gst_buffer_get_wl_buffer (to_render);
 
-      /* attach a wl_buffer if there isn't one yet */
-      if (G_UNLIKELY (!wlbuffer)) {
-        mem = gst_buffer_peek_memory (to_render, 0);
-        wbuf = gst_wl_shm_memory_construct_wl_buffer (mem, sink->display,
+        /* attach a wl_buffer if there isn't one yet */
+        if (G_UNLIKELY (!wlbuffer)) {
+          mem = gst_buffer_peek_memory (to_render, 0);
+          wbuf = gst_wl_shm_memory_construct_wl_buffer (mem, sink->display,
             &sink->video_info);
 
-        if (G_UNLIKELY (!wbuf))
-          goto no_wl_buffer_shm;
+          if (G_UNLIKELY (!wbuf))
+            goto no_wl_buffer_shm;
 
-        gst_buffer_add_wl_buffer (to_render, wbuf, sink->display);
-      }
+          gst_buffer_add_wl_buffer (to_render, wbuf, sink->display);
+        }
 
-      if (!gst_video_frame_map (&dst, &sink->video_info, to_render,
+        if (!gst_video_frame_map (&dst, &sink->video_info, to_render,
               GST_MAP_WRITE))
-        goto dst_map_failed;
+          goto dst_map_failed;
 
-      if (!gst_video_frame_map (&src, &src_info, buffer, GST_MAP_READ)) {
-        gst_video_frame_unmap (&dst);
-        goto src_map_failed;
-      }
+        if (!gst_video_frame_map (&src, &src_info, buffer, GST_MAP_READ)) {
+          gst_video_frame_unmap (&dst);
+          goto src_map_failed;
+        }
 
-      gst_video_frame_copy (&dst, &src);
+        gst_video_frame_copy (&dst, &src);
 
-      gst_video_frame_unmap (&src);
-      gst_video_frame_unmap (&dst);
+        gst_video_frame_unmap (&src);
+        gst_video_frame_unmap (&dst);
 
-      goto render;
+        goto render;
+      }
     }
-  }
 
-  if (!wbuf)
-    goto no_wl_buffer;
+    if (!wbuf)
+      goto no_wl_buffer;
 
-  gst_buffer_add_wl_buffer (buffer, wbuf, sink->display);
-  to_render = buffer;
-}else{
-  wlbuf_ops wlbufops;
-  GstMemory *mem_bak = NULL;
-			 GST_LOG_OBJECT (sink, "buffer %p does not have a wl_buffer from our "
+    gst_buffer_add_wl_buffer (buffer, wbuf, sink->display);
+    to_render = buffer;
+  }else{
+    wlbuf_ops wlbufops;
+    GstMemory *mem_bak = NULL;
+    GST_LOG_OBJECT (sink, "buffer %p does not have a wl_buffer from our "
 					"display, creating it", buffer);
 
-			 if (G_UNLIKELY (!sink->buffer_table)) {
-				sink->buffer_table = g_hash_table_new_full (g_int64_hash, g_int64_equal,
+    if (G_UNLIKELY (!sink->buffer_table)) {
+      sink->buffer_table = g_hash_table_new_full (g_int64_hash, g_int64_equal,
 					  g_free, destroy_gstwl_buffer);
-			 }
+    }
 #ifdef USE_GBM
-			 /* put fd and offset into a int64 key*/
-			 key = ((gint64)(ionBufFdMeta->fd & 0xFFFFFFFF) << 32) | (ionBufFdMeta->meta_fd & 0xFFFFFFFF);
-			 GST_LOG_OBJECT (sink, "gbm buffer %p fd %d meta_fd %d ", buffer,ionBufFdMeta->fd,ionBufFdMeta->meta_fd);
+     /* put fd and offset into a int64 key*/
+    key = ((gint64)(ionBufFdMeta->fd & 0xFFFFFFFF) << 32) | (ionBufFdMeta->meta_fd & 0xFFFFFFFF);
+    GST_LOG_OBJECT (sink, "gbm buffer %p fd %d meta_fd %d ", buffer,ionBufFdMeta->fd,ionBufFdMeta->meta_fd);
 #else
-  key = ((gint64)(ionBufFdMeta->fd & 0xFFFFFFFF) << 32) | (ionBufFdMeta->offset & 0xFFFFFFFF);
-  GST_LOG_OBJECT (sink, "egl buffer %p fd %d offset %d ", buffer,ionBufFdMeta->fd,ionBufFdMeta->offset);
+    key = ((gint64)(ionBufFdMeta->fd & 0xFFFFFFFF) << 32) | (ionBufFdMeta->offset & 0xFFFFFFFF);
+    GST_LOG_OBJECT (sink, "egl buffer %p fd %d offset %d ", buffer,ionBufFdMeta->fd,ionBufFdMeta->offset);
 #endif
-			 gstwlbuf = (GstWlBuffer *) g_hash_table_lookup(sink->buffer_table, &key);
-			 /* the underlying memory may be changed when the new gstbuffer
-			  * has same fd and offset of an old gstbuffer to which a gstwlbuf
-			  * was related */
-			 if (gst_buffer_n_memory (buffer)) {
-			   GstMapInfo map;
-
-			   mem_bak = memory = gst_buffer_get_memory (buffer, 0);
-			   if(gstwlbuf && gstwlbuf->data){
-			     gst_memory_map (memory, &map, GST_MAP_READ);
-			     if (gstwlbuf && gstwlbuf->data != map.data) {
-				 g_hash_table_remove (sink->buffer_table, &key);
-				 gstwlbuf = NULL;
-				 printf("gstwlbuf 0x%x, gstwlbuf->data 0x%x, map.data 0x%x\n", gstwlbuf, gstwlbuf->data, map.data);
-			     }
-			     gst_memory_unmap (memory, &map);
-			   }
-			 }
-			 if (memory)
-			   gst_memory_unref (memory);
-               /* it would be better to just initiate ops once at global resource
-          * registry and move related parts to wlbuffer module */
-         if (sink->display->gbmbuf) {
-           wlbufops.create = gst_wayland_sink_create_wl_buffer_gbm;
-           wlbufops.add = gst_buffer_add_gbm_wl_buffer;
-           wlbufops.set = gst_buffer_set_gbm_wl_buffer;
-         } else {
-           wlbufops.create = gst_wayland_sink_create_wl_buffer;
-           wlbufops.add = gst_buffer_add_eglwl_buffer;
-           wlbufops.set = gst_buffer_set_eglwl_buffer;
-         }
-			 if (!gstwlbuf) {
-			   /* create a new wl_buffer */
-			   gint64 *bufkey = g_malloc(sizeof(*bufkey));
-			   gstwlbuf = g_object_new (GST_TYPE_WL_BUFFER, NULL);
-			   *bufkey = key;
-
-			   wlbufops.create (sink, gstwlbuf, ionBufFdMeta);
-
-           if (gstwlbuf->wlbuffer) {
-             wlbufops.add (buffer, sink->display, gstwlbuf);
-             /* although memory pointer won't be set to NULL,
-              * remove the indicated dependence */
-             GstMapInfo map1;
-             gst_memory_map (mem_bak, &map1, GST_MAP_READ);
-             gstwlbuf->data = map1.data;
-             gst_memory_unmap (mem_bak, &map1);
-             g_hash_table_insert (sink->buffer_table, bufkey, gstwlbuf);
-           } else {
-             g_object_unref (gstwlbuf);
-             if (sink->display->gbmbuf) {
-               GST_WARNING_OBJECT (sink,
+    gstwlbuf = (GstWlBuffer *) g_hash_table_lookup(sink->buffer_table, &key);
+    /* the underlying memory may be changed when the new gstbuffer
+     * has same fd and offset of an old gstbuffer to which a gstwlbuf
+     * was related */
+    if (gst_buffer_n_memory (buffer)) {
+      GstMapInfo map;
+
+      mem_bak = memory = gst_buffer_get_memory (buffer, 0);
+      if(gstwlbuf && gstwlbuf->data){
+        gst_memory_map (memory, &map, GST_MAP_READ);
+        if (gstwlbuf && gstwlbuf->data != map.data) {
+          g_hash_table_remove (sink->buffer_table, &key);
+          gstwlbuf = NULL;
+          GST_WARNING("gstwlbuf 0x%x, gstwlbuf->data 0x%x, map.data 0x%x\n", gstwlbuf, gstwlbuf->data, map.data);
+        }
+        gst_memory_unmap (memory, &map);
+      }
+    }
+    if (memory)
+      gst_memory_unref (memory);
+
+    /* it would be better to just initiate ops once at global resource
+     * registry and move related parts to wlbuffer module */
+    if (sink->display->gbmbuf) {
+      wlbufops.create = gst_wayland_sink_create_wl_buffer_gbm;
+      wlbufops.add = gst_buffer_add_gbm_wl_buffer;
+      wlbufops.set = gst_buffer_set_gbm_wl_buffer;
+    } else {
+      wlbufops.create = gst_wayland_sink_create_wl_buffer;
+      wlbufops.add = gst_buffer_add_eglwl_buffer;
+      wlbufops.set = gst_buffer_set_eglwl_buffer;
+    }
+    if (!gstwlbuf) {
+      /* create a new wl_buffer */
+      gint64 *bufkey = g_malloc(sizeof(*bufkey));
+      gstwlbuf = g_object_new (GST_TYPE_WL_BUFFER, NULL);
+      *bufkey = key;
+
+      wlbufops.create (sink, gstwlbuf, ionBufFdMeta);
+
+      if (gstwlbuf->wlbuffer) {
+        wlbufops.add (buffer, sink->display, gstwlbuf);
+        /* although memory pointer won't be set to NULL,
+         * remove the indicated dependence */
+        GstMapInfo map1;
+        gst_memory_map (mem_bak, &map1, GST_MAP_READ);
+        gstwlbuf->data = map1.data;
+        gst_memory_unmap (mem_bak, &map1);
+        g_hash_table_insert (sink->buffer_table, bufkey, gstwlbuf);
+      } else {
+        g_object_unref (gstwlbuf);
+        if (sink->display->gbmbuf) {
+          GST_WARNING_OBJECT (sink,
                  " we can not get the wl buffer in time, ignore it");
-               goto done;
-             } else {
-               /* to do :*/
-               goto no_wl_buffer;
-             }
-           }
-         } else {
-           if (gstwlbuf->used_by_compositor == TRUE) {
-             /* if we render the same buffer continuously */
-             GST_WARNING_OBJECT (sink,
-               "the last same buffer is still in rendering (e.g. changing video rate)");
-             goto done;
-           } else  /* update userdata */
-             wlbufops.set (gstwlbuf, buffer);
-         }
-			 if (gstwlbuf) {
-				to_render = buffer;
-			 } else {
-
-			  GstMapInfo src;
-			  /* we don't know how to create a wl_buffer directly from the provided
-			   * memory, so we have to copy the data to a memory that we know how
-			   * to handle... */
-
-			  GST_LOG_OBJECT (sink, "buffer %p cannot have a wl_buffer, "
+          goto done;
+        } else {
+          /* to do :*/
+          goto no_wl_buffer;
+        }
+      }
+    } else {
+      if (gstwlbuf->used_by_compositor == TRUE) {
+        /* if we render the same buffer continuously */
+        GST_WARNING_OBJECT (sink,
+             "the last same buffer is still in rendering (e.g. changing video rate)");
+        goto done;
+      } else  /* update userdata */
+        wlbufops.set (gstwlbuf, buffer);
+    }
+    if (gstwlbuf) {
+      to_render = buffer;
+    } else {
+
+      GstMapInfo src;
+      /* we don't know how to create a wl_buffer directly from the provided
+       * memory, so we have to copy the data to a memory that we know how
+       * to handle... */
+
+      GST_LOG_OBJECT (sink, "buffer %p cannot have a wl_buffer, "
 				  "copying to wl_shm memory", buffer);
 
-			  /* sink->pool always exists (created in set_caps), but it may not
-			   * be active if upstream is not using it */
-			  if (!gst_buffer_pool_is_active (sink->pool) &&
-				  !gst_buffer_pool_set_active (sink->pool, TRUE))
-				goto activate_failed;
-
-			  ret = gst_buffer_pool_acquire_buffer (sink->pool, &to_render, NULL);
-			  if (ret != GST_FLOW_OK)
-				goto no_buffer;
-
-			  /* the first time we acquire a buffer,
-			   * we need to attach a wl_buffer on it */
-			  wlbuffer = gst_buffer_get_wl_buffer (to_render);
-			  if (G_UNLIKELY (!wlbuffer)) {
-				mem = gst_buffer_peek_memory (to_render, 0);
-				wbuf = gst_wl_shm_memory_construct_wl_buffer (mem, sink->display,
-					&sink->video_info);
-				if (G_UNLIKELY (!wbuf))
-				  goto no_wl_buffer;
-
-				gst_buffer_add_wl_buffer (to_render, wbuf, sink->display);
-			  }
-
-			  gst_buffer_map (buffer, &src, GST_MAP_READ);
-			  gst_buffer_fill (to_render, 0, src.data, src.size);
-			  gst_buffer_unmap (buffer, &src);
-			}
+      /* sink->pool always exists (created in set_caps), but it may not
+       * be active if upstream is not using it */
+      if (!gst_buffer_pool_is_active (sink->pool) &&
+        !gst_buffer_pool_set_active (sink->pool, TRUE))
+        goto activate_failed;
+
+      ret = gst_buffer_pool_acquire_buffer (sink->pool, &to_render, NULL);
+      if (ret != GST_FLOW_OK)
+        goto no_buffer;
+
+      /* the first time we acquire a buffer,
+       * we need to attach a wl_buffer on it */
+      wlbuffer = gst_buffer_get_wl_buffer (to_render);
+      if (G_UNLIKELY (!wlbuffer)) {
+        mem = gst_buffer_peek_memory (to_render, 0);
+        wbuf = gst_wl_shm_memory_construct_wl_buffer (mem, sink->display,
+                 &sink->video_info);
+
+        if (G_UNLIKELY (!wbuf))
+          goto no_wl_buffer;
+
+        gst_buffer_add_wl_buffer (to_render, wbuf, sink->display);
+      }
+
+      gst_buffer_map (buffer, &src, GST_MAP_READ);
+                      gst_buffer_fill (to_render, 0, src.data, src.size);
+      gst_buffer_unmap (buffer, &src);
+    }
 }
 render:
   /* drop double rendering */
-- 
2.7.4

